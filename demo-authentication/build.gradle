import java.util.regex.Pattern

plugins {
	id 'java-library'
	id 'jacoco'
	id 'maven-publish'
	id("org.sonarqube") version "6.3.1.5724"
}

group = 'app.krista.extensions.krista.authentication'

sonar {
	properties {
		property('sonar.projectName', 'SonarScanner for Krista Global Catalog (outlook-3.0 with Jacoco code coverage)')
		property("sonar.projectKey", "sonar-scanner-outlook-3.0")
		property("sonar.sources", "src/main/java")
		property("sonar.tests", "src/test/java")
		property("sonar.java.binaries", "build/classes/java/main")
		property("sonar.java.test.binaries", "build/classes/java/test")
		property("sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml")
		property("sonar.junit.reportPaths", "build/test-results/test")
	}
}

tasks.test {
	// Generate coverage report after tests run
	finalizedBy(tasks.jacocoTestReport)
}

jacoco {
	toolVersion = "0.8.11"
}

tasks.jacocoTestReport {
	dependsOn(tasks.test)
	reports {
		xml.required = true   // Required for SonarQube
		html.required = true  // Useful for local viewing
		csv.required = false
	}
}

// Ensure Sonar runs only after JaCoCo report generation
tasks.named("sonar") {
	dependsOn(tasks.jacocoTestReport)
}

/*
 * Use extension.name for archiveBaseName, extension.version for version.
 * Resulting jar: <extension.name>-<extension.version>.jar e.g. Demo Authentication-3.0.11.jar
 */
def computedBaseName = "Demo Authentication"
def computedVersion = "local"

tasks.register("setReleaseProperties") {
	dependsOn("generateReleaseProperties")
	doFirst {
		def releasePropsFile = file("release.properties")
		if (releasePropsFile.exists()) {
			def props = new Properties()
			releasePropsFile.withInputStream { stream -> props.load(stream) }
			computedBaseName = (props['extension.name'] ?: computedBaseName).replaceAll(/\s+/, "")
			computedVersion = props['extension.version'] ?: computedVersion

			project.ext.set("finalBaseName", computedBaseName)
			project.version = computedVersion

			println "✔ Loaded extension name = ${computedBaseName}, version = ${computedVersion}"
		} else {
			logger.warn("⚠ release.properties not found; using default values.")
			project.ext.set("finalBaseName", computedBaseName)
			project.version = computedVersion
		}
	}
}

// Resolve Maven repository URL from system or project properties with
// a sensible default so the internal Artifactory is always configured.
def mavenRepoUrl = System.getProperty('MAVEN_URL')
if (!mavenRepoUrl) {
	mavenRepoUrl = project.findProperty('MAVEN_URL') as String
}
if (!mavenRepoUrl) {
	mavenRepoUrl = 'https://packages.cicd.in.antbrains.com/artifactory/libs-release'
}

repositories {
	mavenLocal()
	maven {
		url = uri(mavenRepoUrl)
	}
	mavenCentral()
}

java {
  sourceCompatibility = JavaVersion.VERSION_21
  targetCompatibility = JavaVersion.VERSION_21
}

System.setProperty("extensionVersion", version as String)

dependencies {
	// Internal project dependencies (via multi-project setup in settings.gradle)
	implementation project(':base-authentication')

	// External dependencies (declared explicitly instead of via shared ext.libraries)
	annotationProcessor 'app.krista:extension-impl-anno-processors:1.0.121-rc1'
	compileOnly 'app.krista:krista-apis:1.0.121-rc1'
	compileOnly 'org.glassfish.hk2:hk2-api:2.6.1'

	// Test dependencies
	testImplementation 'com.kristasoft.common:common-test:1.0.52-rc1'
}

/*
    Task to generate release.properties files in below format.
    extension.version=<version>
    extension.name=<name>
    domain.name=<domain>
    ecosystem.name=<ecosystem>
    Every extension developer should update extensionFile and areaFileName with relative path.
 */

abstract class GenerateReleasePropertiesTask extends DefaultTask {
	@TaskAction
	def generateProperties() {
		// Extension metadata (name, version) is defined on DemoAuthenticationExtension
		def extensionFilePath = 'src/main/java/app/krista/extensions/krista/authentication/demo_authentication/DemoAuthenticationExtension.java'
		// Domain/ecosystem metadata is taken from the catalog IntegrationArea
		def areaFilePath = 'src/main/java/app/krista/extensions/krista/authentication/demo_authentication/catalog/IntegrationArea.java'
		def extensionFile = project.file(extensionFilePath)
		def areaFile = project.file(areaFilePath)
		if (!extensionFile.exists()) {
			throw new GradleException("Extension file not found: ${extensionFilePath}")
		}
		if (!areaFile.exists()) {
			throw new GradleException("Area file not found: ${areaFilePath}")
		}
		def properties = new Properties()
		// Pre-compile the regex pattern for better performance
		def keyValuePattern = Pattern.compile(/(\w+)\s*=\s*"([^"]+)"/)
		// Extract Extension annotation information
		extractAnnotationInfo(extensionFile, "@Extension", keyValuePattern) { key, value ->
			if (key == "name") {
				properties.setProperty("extension.name", value)
				logger.lifecycle("Found extension name: ${value}")
			} else if (key == "version") {
				properties.setProperty("extension.version", value)
				logger.lifecycle("Found extension version: ${value}")
			}
		}
		// Extract Domain annotation information
		extractAnnotationInfo(areaFile, "@Domain", keyValuePattern) { key, value ->
			if (key == "name") {
				properties.setProperty("domain.name", value)
				logger.lifecycle("Found domain name: ${value}")
			} else if (key == "ecosystemName") {
				properties.setProperty("ecosystem.name", value)
				logger.lifecycle("Found ecosystem name: ${value}")
			}
		}
		if (!properties.getProperty('extension.version')) {
			throw new GradleException("Could not find extension version in ${extensionFilePath}")
		}
		if (!properties.getProperty('domain.name') || !properties.getProperty('ecosystem.name')) {
			throw new GradleException("Could not find domain name or ecosystem name in ${areaFilePath}")
		}
		def releasePropertiesFile = project.file('release.properties')
		def content = properties.collect { key, value -> "${key}=${value}" }.join('\n')
		releasePropertiesFile.text = content + '\n'
		logger.lifecycle("Generated release.properties with content:\n${content}")
	}
	/**
	 * Extracts annotation information from a file
	 * @param file The file to extract from
	 * @param annotationName The annotation name to look for
	 * @param keyValuePattern The regex pattern to extract key-value pairs
	 * @param processProperty Closure to process each property
	 */
	private static void extractAnnotationInfo(File file, String annotationName, Pattern keyValuePattern, Closure processProperty) {
		StringBuilder annotationText = new StringBuilder()
		boolean inAnnotation = false
		file.eachLine { line ->
			line = line.trim()
			if (line.contains(annotationName)) {
				inAnnotation = true
			}
			if (inAnnotation) {
				annotationText.append(line)
				if (line.contains(")")) {
					inAnnotation = false
					def matcher = keyValuePattern.matcher(annotationText.toString())
					while (matcher.find()) {
						def key = matcher.group(1)
						def value = matcher.group(2)
						processProperty.call(key, value)
					}
				}
			}
		}
	}
}

tasks.register('generateReleaseProperties', GenerateReleasePropertiesTask) {
	group = 'build'
	description = 'Generates release.properties file with extension version and domain information'
}
tasks.named("jar") {
	dependsOn tasks.named("generateReleaseProperties")
}

jar {
		dependsOn tasks.named("setReleaseProperties")
		// Ensure the base-authentication JAR is built before we unpack it into this fat JAR
		dependsOn ":base-authentication:jar"
		archiveBaseName = project.ext.has("finalBaseName") ? project.ext.finalBaseName : "Demo Authentication"

		archiveBaseName = "demo_authentication-extension"

		from {
			configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
		}

		exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
		duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	}

